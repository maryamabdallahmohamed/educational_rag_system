[
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "ad00e7a2-8d61-461d-b985-7253b8e31fbd",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC001-Document Upload - Supported Formats",
    "description": "Verify that the Document Upload page accepts all specified file formats (PDF, TXT, DOC, DOCX, MD, JSON) via both drag-and-drop and file selector.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Upload Successful for XML File').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The Document Upload page did not accept or process the XML file format as expected. This indicates a failure in handling all specified file formats (PDF, TXT, DOC, DOCX, MD, JSON) via drag-and-drop and file selector.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864673285:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864885302122//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.246Z",
    "modified": "2025-12-04T16:14:45.466Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "ec7f528e-fc92-4ebf-874e-db164d3df55b",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC002-Document Upload - Unsupported Formats Rejection",
    "description": "Verify that unsupported file formats are rejected and trigger appropriate error messages during upload.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Unsupported file format detected').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Unsupported file formats were not properly rejected with clear real-time error messages during upload as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864678869:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864855026324//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.346Z",
    "modified": "2025-12-04T16:14:15.159Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "b4d8aef8-6e3e-40e2-a1d8-7885a08f2d44",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC003-Chat Interface - Real-time Q&A",
    "description": "Verify that users can submit questions, receive AI-generated answers with loading indicators, and view conversation history with timestamps.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=No AI response generated').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution failed because the AI-generated answer was not displayed, loading indicator did not appear, or conversation history with timestamps was not verified as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/css/app/layout.css?v=1764864680061:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864680061:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864764065081//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.445Z",
    "modified": "2025-12-04T16:12:44.198Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "f6046a1d-eeed-43cc-88f8-872292c35051",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC004-Chat Interface - Empty or Invalid Question Handling",
    "description": "Ensure that empty questions or invalid inputs are not submitted and the application prompts the user accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Submission Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The application did not block empty or invalid question submissions and did not show the expected validation error or user feedback as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864678635:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864884521882//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.453Z",
    "modified": "2025-12-04T16:14:44.690Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "116dbef9-e3d3-4957-83df-7c7411549abf",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC005-AI Features - Document Summarization",
    "description": "Test that the automatic document summarization feature generates accurate, concise summaries quickly when triggered.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Summary generation complete and accurate').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: The automatic document summarization feature did not generate an accurate and concise summary as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864678871:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864878668469//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.460Z",
    "modified": "2025-12-04T16:14:38.833Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "8619fcb2-fe6b-434b-9d71-67cb5ffe2943",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC006-AI Features - CPA Agent Processing",
    "description": "Verify CPA Agent processing returns correct processed content and handles errors gracefully.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=CPA Agent processed content successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: CPA Agent processing did not return the expected processed content results or failed to handle API errors gracefully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/webpack.js?v=1764864680058:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864680058:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/176486488412529//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.539Z",
    "modified": "2025-12-04T16:14:44.279Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "825e6523-2eac-4cc5-9794-f4385931b739",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC007-UI Accessibility - Keyboard Navigation and Screen Reader Support",
    "description": "Ensure all UI components, including chat inputs, buttons, menus, and dialogs, are fully operable via keyboard and accessible to screen readers.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Keyboard Navigation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The UI components are not fully operable via keyboard or accessible to screen readers as per the test plan requirements.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/media/028c0d39d2e8f589-s.p.woff2:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/app/page.js:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864685073:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864867027952//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.546Z",
    "modified": "2025-12-04T16:14:27.191Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "b01b2427-4831-44db-a548-2ab0463c8cdb",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC008-Navigation Bar - Responsiveness and Menu Functionality",
    "description": "Test that the navigation bar works correctly on desktop and mobile, with responsive menus, smooth scrolling, and active state highlighting.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Navigation Bar Test Passed').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test plan execution failed: Navigation bar functionality on desktop and mobile did not work as expected, including responsive menus, smooth scrolling, and active state highlighting.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864678875:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864876754771//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.553Z",
    "modified": "2025-12-04T16:14:37.016Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "1513a6a2-a4c3-4f28-88c5-584bae3d0e8a",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC009-Theme Provider - Dark and Light Mode Toggle with Persistence",
    "description": "Verify seamless toggling between dark and light modes, and that the chosen theme persists across user sessions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Dark Mode Activated Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The application did not switch to dark mode instantly or preserve the selected theme across sessions as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864679539:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/app/page.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864882323581//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.559Z",
    "modified": "2025-12-04T16:14:42.488Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "67db823b-ff90-49ea-9d90-20fcc8d2f054",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC010-RAG API Integration - Successful Document Upload and Query",
    "description": "Confirm successful interactions with the backend RAG API for document upload and question answering, maintaining session state.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Upload Successful and Answer Received').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The backend RAG API did not successfully process the document upload or return a valid answer, or the session state was not maintained as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864677824:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864890395815//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.604Z",
    "modified": "2025-12-04T16:14:50.550Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "54e6588b-8ee1-42dc-be9c-3f4b7cf28813",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC011-RAG API Integration - Error Handling and Retry Mechanism",
    "description": "Verify that errors from the RAG backend API during document upload or Q&A are handled gracefully with user feedback and offer retry options.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Document upload and Q&A API failure handled successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The system did not display a meaningful error message or retry option when the RAG backend API failed during document upload or Q&A, as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864679541:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/app/page.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864846583691//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.610Z",
    "modified": "2025-12-04T16:14:06.758Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "75ad1f49-283e-4b11-9e77-59948954737e",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC012-Custom Hooks - Mobile Detection Hook Functionality",
    "description": "Test that the custom mobile detection hook correctly identifies device type and triggers responsive UI behaviors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Device Type: Desktop View Detected').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The custom mobile detection hook did not correctly identify the device type or trigger responsive UI behaviors as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/media/028c0d39d2e8f589-s.p.woff2:0:0)\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864680056:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864877691452//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.617Z",
    "modified": "2025-12-04T16:14:37.881Z"
  },
  {
    "projectId": "6586584f-20d8-4bb5-a728-e3294a9ff313",
    "testId": "754165cf-d953-4a18-8169-7e3270edd876",
    "userId": "c4d87438-40e1-7006-1b2f-3567d1823320",
    "title": "TC013-Toast Notifications - Display and Dismissal",
    "description": "Ensure custom toast notifications triggered by hooks display messages correctly and can be dismissed manually or auto-dismiss after a timeout.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Toast notification: Operation completed successfully!').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Custom toast notifications did not display as expected or were not dismissed properly according to the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_INCOMPLETE_CHUNKED_ENCODING (at http://localhost:3000/_next/static/chunks/main-app.js?v=1764864678873:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4d87438-40e1-7006-1b2f-3567d1823320/1764864888847027//tmp/test_task/result.webm",
    "created": "2025-12-04T16:11:09.623Z",
    "modified": "2025-12-04T16:14:49.066Z"
  }
]
